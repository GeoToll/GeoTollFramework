#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
#ifndef GEOTOLLFRAMEWORK_SWIFT_H
#define GEOTOLLFRAMEWORK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnon-modular-include-in-framework-module"
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#pragma clang diagnostic pop
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFAudio;
@import CoreBluetooth;
@import CoreData;
@import CoreLocation;
@import Foundation;
@import ObjectiveC;
@import UIKit;
@import UserNotifications;
#endif

#import <GeoTollFramework/GeoTollFramework.h>

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeoTollFramework",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class NSString;

SWIFT_CLASS("_TtC16GeoTollFramework9APIConfig")
@interface APIConfig : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) APIConfig * _Nonnull instance;)
+ (APIConfig * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (NSString * _Nonnull)getAuthURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getrevokeAccessURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getRegisterURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getinviteRegisterURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getRequestPasswordResetURL:(NSString * _Nonnull)email SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getProfileUpdateURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getSetProfileEmailName SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getPhoneURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getSendOtpURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getVerifyOtpURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getPasswordURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAddressURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getValidateVehicleURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAddValidatedVehicleURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getRejectValidatedVehicleURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getDeleteUserVehicleURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getInviteSubuserURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getSubUsersURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getDeleteSubuserURL:(NSString * _Nonnull)accountID SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getReactivateSubuserURL:(NSString * _Nonnull)accountID SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getPrivacyPolicyURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getTermsConditionURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getOdometerHistoryURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getOdometerURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getVinURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getFaqsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getHelpURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getContactUsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getParticipantAgreementURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getOcrFilterURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getSubmitReportURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUpdatePasswordURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getTripHistoryURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getTransactionHistoryURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getMileageHistoryURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUpdateInviteURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUpdateDeviceTokenURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUpdateUserVehicleURL:(NSString * _Nonnull)vehicleId SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getPaymentMethodsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAddressesURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getFinanceConfig SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getLookUpBankRoutingNumber SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getDeleteAddresURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAddPaymentMethodURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAddAddressURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAccountStatementsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getAccountStatementPDFURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getPaymentTransactionsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getTollRunURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUserAuditURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getGeofenceURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getRefreshTokenURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getGPSPayloadURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getETollingPayloadURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUserNotificationsURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUserLogURL SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUserVehicles SWIFT_WARN_UNUSED_RESULT;
@end


@class NSNumber;
@class NSMutableDictionary;
@class NSMutableArray;
@class NSDictionary;

SWIFT_CLASS("_TtC16GeoTollFramework15CoreDataManager")
@interface CoreDataManager : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) CoreDataManager * _Nonnull shareInstance;)
+ (CoreDataManager * _Nonnull)shareInstance SWIFT_WARN_UNUSED_RESULT;
- (void)addUserAuditWithEvent:(NSString * _Nonnull)event val:(NSString * _Nonnull)val val2:(NSString * _Nonnull)val2 UTCTime:(NSString * _Nonnull)UTCTime userTime:(NSString * _Nonnull)userTime vehicleId:(NSString * _Nonnull)vehicleId tollrunId:(NSString * _Nonnull)tollrunId;
- (void)addGPSPayLoadWithJsonString:(NSString * _Nonnull)jsonString tollRunID:(NSString * _Nonnull)tollRunID sequenceNum:(NSNumber * _Nonnull)sequenceNum isTemp:(BOOL)isTemp;
- (void)addGPSETollPayLoadWithJsonString:(NSString * _Nonnull)jsonString sequenceNum:(NSNumber * _Nonnull)sequenceNum time:(NSString * _Nonnull)time tollrunId:(NSString * _Nonnull)tollrunId isTemp:(BOOL)isTemp;
- (void)addDebugLogWithJsonString:(NSString * _Nonnull)jsonString sequnceNum:(double)sequnceNum time:(NSString * _Nonnull)time;
- (NSArray<NSMutableDictionary *> * _Nonnull)fetchUserAudit SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSMutableDictionary *> * _Nonnull)fetchRUCGPSPayload:(NSString * _Nonnull)id SWIFT_WARN_UNUSED_RESULT;
/// This method returns all the stores toll run id.
/// Here is the discussion. This method fetches all the available payload and gets the toll run id and returns the sorted array of toll run id’s.
///
/// returns:
/// Array of toll run id as String.
- (NSArray<NSString *> * _Nonnull)fetchRUCTollRunIdArray SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSMutableDictionary *> * _Nonnull)fetchGPSETollPayload SWIFT_WARN_UNUSED_RESULT;
- (NSArray<NSMutableDictionary *> * _Nonnull)fetchDebugLogs SWIFT_WARN_UNUSED_RESULT;
- (void)updateRucGpsPayloadWithTempTollRun:(NSString * _Nonnull)tempTollRun tollRunId:(NSString * _Nonnull)tollRunId completion:(void (^ _Nonnull)(void))completion;
- (void)updateETollGpsPayloadWithTempTollRun:(NSNumber * _Nonnull)tempTollRun tollRunId:(NSNumber * _Nonnull)tollRunId completion:(void (^ _Nonnull)(void))completion;
- (void)updateETollGpsPayloadWithSequenceWithTempTollRun:(NSString * _Nonnull)tempTollRun tollRunId:(NSNumber * _Nonnull)tollRunId sequence:(NSNumber * _Nonnull)sequence;
- (void)deleteUserAuditWithPersons:(NSArray<NSMutableDictionary *> * _Nonnull)persons;
- (void)deleteRUCGPSPayloadWithTollRunId:(NSString * _Nonnull)tollRunId payloads:(NSMutableArray * _Nonnull)payloads;
- (void)deleteGPSETollPayloadWithPersons:(NSDictionary * _Nonnull)persons time:(NSString * _Nonnull)time sequence:(uint32_t)sequence;
- (void)deleteDebugLogPayloadWithSequence:(NSDictionary<NSString *, id> * _Nonnull)sequence;
- (void)deleteOldDebugLogs;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSEntityDescription;
@class NSManagedObjectContext;

SWIFT_CLASS_NAMED("DebugLog")
@interface DebugLog : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end



@interface DebugLog (SWIFT_EXTENSION(GeoTollFramework))
@property (nonatomic, copy) NSString * _Nullable debugLog;
@property (nonatomic) double sequence;
@property (nonatomic, copy) NSString * _Nullable timeStamp;
@end


SWIFT_CLASS_NAMED("GPSETollPayLoad")
@interface GPSETollPayLoad : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end



@interface GPSETollPayLoad (SWIFT_EXTENSION(GeoTollFramework))
@property (nonatomic) BOOL isTemp;
@property (nonatomic, copy) NSString * _Nullable payload;
@property (nonatomic) int32_t sequenceNum;
@property (nonatomic, copy) NSString * _Nullable timeStamp;
@property (nonatomic, copy) NSString * _Nullable tollRunId;
@end


SWIFT_CLASS_NAMED("UserAudit")
@interface UserAudit : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("GPSRUCPayLoad")
@interface GPSRUCPayLoad : UserAudit
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end


@interface GPSRUCPayLoad (SWIFT_EXTENSION(GeoTollFramework))
@property (nonatomic) BOOL isTemp;
@property (nonatomic, copy) NSString * _Nullable payload;
@property (nonatomic) int32_t sequenceNum;
@property (nonatomic, copy) NSString * _Nullable tollRunId;
@end


SWIFT_CLASS("_TtC16GeoTollFramework12GTAPIManager")
@interface GTAPIManager : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTAPIManager * _Nonnull sharedInstance;)
+ (GTAPIManager * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeoTollFramework12GTApiRequest")
@interface GTApiRequest : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTApiRequest * _Nonnull instance;)
+ (GTApiRequest * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeoTollFramework14GTAudioSession")
@interface GTAudioSession : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTAudioSession * _Nonnull sharedInstance;)
+ (GTAudioSession * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// This method initializes the audio session.
/// This method initializes the instance of <code>AVAudioSession</code>. It also adds an observer for audio session route changes and registers the AV session.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Ensures the audio session is initialized and observers are set up.
///   </li>
/// </ol>
- (void)initializeAVSession;
/// This method deinitializes the audio session.
/// This method deinitializes the instance of <code>AVAudioSession</code> and removes the associated observers.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Cleans up the audio session and removes observers to prevent memory leaks.
///   </li>
/// </ol>
- (void)stop;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class CBCentralManager;

SWIFT_CLASS("_TtC16GeoTollFramework18GTBluetoothManager")
@interface GTBluetoothManager : NSObject <CBCentralManagerDelegate, CBPeripheralDelegate>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTBluetoothManager * _Nonnull sharedInstance;)
+ (GTBluetoothManager * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) BOOL isBluetoothPermissionGranted;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)requestPermission;
- (void)stop;
- (void)redirectToSettingsWithCompletion:(void (^ _Nonnull)(void))completion;
- (BOOL)getBluetoothAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (void)centralManagerDidUpdateState:(CBCentralManager * _Nonnull)central;
- (void)centralManager:(CBCentralManager * _Nonnull)central willRestoreState:(NSDictionary<NSString *, id> * _Nonnull)dict;
@end


SWIFT_CLASS("_TtC16GeoTollFramework15GTCameraManager")
@interface GTCameraManager : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTCameraManager * _Nonnull shared;)
+ (GTCameraManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (BOOL)getCurrentAuthorizationStatus SWIFT_WARN_UNUSED_RESULT;
- (void)requestAccessWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class CLLocation;

SWIFT_CLASS("_TtC16GeoTollFramework20GTGlobalStateLogging")
@interface GTGlobalStateLogging : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTGlobalStateLogging * _Nonnull sharedInstance;)
+ (GTGlobalStateLogging * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, copy) NSString * _Nonnull applicationStateGS;
@property (nonatomic) NSInteger appStateGS;
@property (nonatomic, strong) NSNumber * _Nonnull sequenceGS;
@property (nonatomic, strong) NSNumber * _Nonnull logSequenceGS;
@property (nonatomic, copy) NSString * _Nonnull queSizeGS;
@property (nonatomic, copy) NSString * _Nonnull distanceFromLastLocationGS;
@property (nonatomic, copy) NSString * _Nonnull locationAccuracyGS;
@property (nonatomic, strong) CLLocation * _Nonnull latLongGS;
@property (nonatomic, copy) NSString * _Nonnull latLongTimeGS;
@property (nonatomic, strong) CLLocation * _Nonnull lastLatLongGS;
@property (nonatomic, copy) NSString * _Nonnull lastLatLongTimeGS;
@property (nonatomic) int32_t totalETollRecordsSendedGS;
@property (nonatomic) int32_t totalRUCRecordsSendedGS;
@property (nonatomic) int32_t totalRecordCollectedPolygonGS;
@property (nonatomic) int32_t totalRecordCollectedALLGS;
@property (nonatomic, copy) NSString * _Nonnull tollrunActiveGS;
@property (nonatomic, copy) NSString * _Nonnull tollrunActiveSegmentGS;
@property (nonatomic, copy) NSString * _Nonnull regionPolygonGS;
@property (nonatomic, copy) NSString * _Nonnull plazaPolygonGS;
@property (nonatomic, copy) NSString * _Nonnull gantryPolygonGS;
@property (nonatomic, copy) NSString * _Nonnull distanceFilterGantryGS;
@property (nonatomic, copy) NSString * _Nonnull distanceFilterGS;
@property (nonatomic, copy) NSString * _Nonnull internetAvailbleGS;
@property (nonatomic, copy) NSString * _Nonnull createdTimeGS;
@property (nonatomic, copy) NSString * _Nonnull currentTimeGS;
@property (nonatomic, copy) NSString * _Nonnull currentLocationPremissionGS;
@property (nonatomic, copy) NSString * _Nonnull currentBluetoothPremissionGS;
@property (nonatomic, copy) NSString * _Nonnull currentNotificationPremissionGS;
@property (nonatomic, copy) NSString * _Nonnull intervalTimeGS;
@property (nonatomic) double currentSpeedGS;
@property (nonatomic) double currentBatteryLevelGS;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (void)changeLocationServiceStatusWithStatus:(NSString * _Nonnull)status time:(NSString * _Nonnull)time;
- (void)changeCorrdinatesStatusWithCurrentLatLong:(CLLocation * _Nonnull)currentLatLong time:(NSString * _Nonnull)time isFromPL:(BOOL)isFromPL;
- (void)calculateDistanceWithLatestLatLong:(CLLocation * _Nonnull)latestLatLong;
@end

@class CLLocationManager;
@class CLRegion;

SWIFT_CLASS("_TtC16GeoTollFramework17GTLocationManager")
@interface GTLocationManager : NSObject <CLLocationManagerDelegate, UIApplicationDelegate>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTLocationManager * _Nonnull sharedInstance;)
+ (GTLocationManager * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) CLLocationManager * _Nullable locationManager;
/// Initializes the <code>GTLocationManager</code> instance.
/// This initializer sets up the location manager, logs the initialization process,
/// initializes the geofence monitoring if necessary, requests an initial location update,
/// and registers observers for various notifications.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Requests the user’s permission to access location services while the app is in use.
/// This method requests the “When In Use” location authorization from the user.
/// The method sets a flag indicating that the permission has been requested.
- (void)requestWhileInUsePermission;
/// Requests the user’s permission to always access location services.
/// This method requests the “Always” location authorization from the user.
- (void)requestAlwaysPermission;
/// Initializes and starts the location services.
/// This method performs the following actions:
/// <ul>
///   <li>
///     Initializes the location manager.
///   </li>
///   <li>
///     Requests access to location services and starts location updates.
///   </li>
///   <li>
///     Requests an initial location update.
///   </li>
///   <li>
///     Updates the region geofence if the last known location is available.
///   </li>
///   <li>
///     Starts the utility timer.
///   </li>
///   <li>
///     Logs the service start event.
///   </li>
/// </ul>
- (void)start;
/// Stops and deactivates the location services.
/// This method performs the following actions:
/// <ul>
///   <li>
///     Stops monitoring all regions.
///   </li>
///   <li>
///     Stops the utility timer.
///   </li>
///   <li>
///     Deinitializes the location manager.
///   </li>
///   <li>
///     Logs the service stop event.
///   </li>
/// </ul>
- (void)stop;
/// Sends GPS payloads based on the current system settings and internet availability.
/// This method checks whether eToll or RUC (Remote User Communication) features are enabled and if the internet is available.
/// It then fetches and sends the appropriate payload based on the enabled features.
/// The method performs the following checks:
/// <ul>
///   <li>
///     If eToll is enabled and the internet is available, it sends the eToll GPS payload.
///   </li>
///   <li>
///     If RUC is enabled and either eToll is not enabled or non-BLE tolling is disabled, and the internet is available, it sends the RUC GPS payload.
///   </li>
/// </ul>
- (void)sendPayload;
/// Requests a location update from the location manager.
/// This method checks if the <code>locationManager</code> is available. If so, it requests a location update and logs the request.
/// If the <code>locationManager</code> is not available, it logs a message indicating that the request could not be made.
- (void)requestLocationUpdate;
/// Retrieves the most recent location update.
/// This method returns the current value of the <code>lastLocation</code> property. If <code>lastLocation</code> is <code>nil</code>, indicating that no location
/// data is available, the method will also return <code>nil</code>.
///
/// returns:
/// An optional <code>CLLocation</code> object representing the most recent location, or <code>nil</code> if no location has been recorded.
- (CLLocation * _Nullable)getLatestLocation SWIFT_WARN_UNUSED_RESULT;
/// Checks if the location authorization status allows always-on location access.
/// This method returns the current state of the <code>isAlwaysAllow</code> flag, which indicates if the location authorization status
/// allows the app to access location data at all times, even when the app is in the background.
///
/// returns:
/// A Boolean value indicating whether the location authorization is set to “Always Allow”.
- (BOOL)isLocationAuthAlwaysAllow SWIFT_WARN_UNUSED_RESULT;
/// Checks if the location authorization status allows usage while the app is in use.
/// This method returns the current state of the <code>isWhileInUse</code> flag, which indicates if the location authorization status
/// allows the app to access location data only while it is in use.
///
/// returns:
/// A Boolean value indicating whether the location authorization is set to “While In Use”.
- (BOOL)isLocationAuthWhileInUse SWIFT_WARN_UNUSED_RESULT;
- (void)locationManagerDidChangeAuthorization:(CLLocationManager * _Nonnull)manager;
/// Handles location updates from the location manager.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     manager: The <code>CLLocationManager</code> instance that triggered the update.
///   </li>
///   <li>
///     locations: An array of <code>CLLocation</code> objects containing updated location information.
///   </li>
/// </ul>
/// This method processes the most recent location update, performs necessary actions such as logging, token refresh, toll run checks,
/// geofence monitoring, and accuracy checks. If no location is found, it logs a debug message and exits.
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
/// Handles the error event when the location manager fails to update the location.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     manager: The <code>CLLocationManager</code> instance that encountered the error.
///   </li>
///   <li>
///     error: The <code>Error</code> object representing the error that occurred.
///   </li>
/// </ul>
/// This method logs an error message indicating that the location update callback has failed.
- (void)locationManager:(CLLocationManager * _Nonnull)manager didFailWithError:(NSError * _Nonnull)error;
/// Handles the event when the user exits a monitored region.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     manager: The <code>CLLocationManager</code> instance that triggered the event.
///   </li>
///   <li>
///     region: The <code>CLRegion</code> object representing the region that was exited.
///   </li>
/// </ul>
/// This method logs the event of the user exiting a regional geofence and requests a location update.
- (void)locationManager:(CLLocationManager * _Nonnull)manager didExitRegion:(CLRegion * _Nonnull)region;
/// Processes a new location update trigger and handles GPS storage and toll run conditions.
/// This method checks if Bluetooth permission is required and whether a toll run should be started.
/// If the conditions are not met, it checks and stops the toll run based on the last known location.
- (void)processNewLocationUpdateTrigger;
@end


SWIFT_CLASS("_TtC16GeoTollFramework18GTLocationProducer")
@interface GTLocationProducer : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTLocationProducer * _Nonnull instance;)
+ (GTLocationProducer * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// To set ROI state.
/// Here is the discussion. This methods sets ROI State for current class.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters must be <em>ROIState</em> type
///   </li>
/// </ol>
/// \param state ROIState.
///
- (void)setROIStateWithState:(ROIState)state;
/// This method build the obtained location to required format.
/// Here is the discussion. This methods takes location as input and creates a dictionary with deviceId, user_id, id, vehicle_id, tollrun_id, speed, bearing, radius, bs, sequence, appversion, sdk_version, upload_status, numpass, logStatus, inside_local_geofence, longlat, usertime, created_at. After creating the dictionary, it is converted to string and stored in CoreData.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters must be <em>CLLocation</em> type
///   </li>
/// </ol>
/// \param location User location
///
- (void)buildGPSLogsWithLocation:(CLLocation * _Nonnull)location;
/// This method call the send RUC payload method according the interval.
/// Here is the discussion. This methods calls the send RUC payload method by mesuring the time difference between the last and current location timestamps comparing with the interval set in the backend.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters must be <em>CLLocation</em> type
///   </li>
/// </ol>
/// \param location User location.
///
- (void)sendWithInterval:(CLLocation * _Nonnull)location;
/// This method fetches and sends the Etoll GPS payload.
/// Here is the discussion. This method fetches the pending Etoll GPS payload from CoreData and calls Send method.
- (void)fetchAndSendGPSPayloadWithCompletion:(void (^ _Nonnull)(void))completion;
/// This method fetches and sends the RUC GPS payload.
/// Here is the discussion. This method fetches all the stored toll run id and fetches the payload for the respective toll run id and calls Send method.
- (void)fetchAndSendRUCPayloadWithCompletion:(void (^ _Nonnull)(void))completion;
@end

@class UNUserNotificationCenter;

SWIFT_CLASS("_TtC16GeoTollFramework21GTNotificationManager")
@interface GTNotificationManager : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTNotificationManager * _Nonnull sharedInstance;)
+ (GTNotificationManager * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) UNUserNotificationCenter * _Nonnull center;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (void)requestAuthorizationWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (void)getCurrentAuthorizationStatusWithCompletion:(void (^ _Nonnull)(BOOL))completion;
- (void)sendLocalNotificationWithTitle:(NSString * _Nonnull)title body:(NSString * _Nonnull)body delay:(NSTimeInterval)delay identifier:(NSString * _Nonnull)identifier;
@end

@class UNNotification;
@class UNNotificationResponse;

@interface GTNotificationManager (SWIFT_EXTENSION(GeoTollFramework)) <UNUserNotificationCenterDelegate>
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center willPresentNotification:(UNNotification * _Nonnull)notification withCompletionHandler:(void (^ _Nonnull)(UNNotificationPresentationOptions))completionHandler;
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center didReceiveNotificationResponse:(UNNotificationResponse * _Nonnull)response withCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
@end


SWIFT_CLASS("_TtC16GeoTollFramework15GTNotifications")
@interface GTNotifications : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTNotifications * _Nonnull instance;)
+ (GTNotifications * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeoTollFramework15GTSystemMonitor")
@interface GTSystemMonitor : NSObject <UIApplicationDelegate>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTSystemMonitor * _Nonnull sharedInstanceUtility;)
+ (GTSystemMonitor * _Nonnull)sharedInstanceUtility SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (void)startAudit;
- (void)stopAudit;
- (BOOL)isInternetAvailable SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC16GeoTollFramework14GTTokenManager")
@interface GTTokenManager : NSObject
/// Singleton instance of the token manager.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTTokenManager * _Nonnull instance;)
+ (GTTokenManager * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Private initializer to enforce singleton pattern.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Refreshes the authentication token.
/// This method checks if a valid refresh token is available, and if so, it sends a request to refresh the token.
/// The date of the token refresh request is stored regardless of whether the refresh is successful or not.
/// <h1>Discussion:</h1>
/// <ol>
///   <li>
///     Retrieves the refresh token from the session.
///   </li>
///   <li>
///     If no refresh token is available, the method returns early.
///   </li>
///   <li>
///     Prepares device information for the request.
///   </li>
///   <li>
///     Logs the attempt to refresh the token.
///   </li>
///   <li>
///     Checks if the internet is available before making the request.
///   </li>
///   <li>
///     Initializes the session manager with the refresh token.
///   </li>
///   <li>
///     Defines the URL for the token refresh endpoint.
///   </li>
///   <li>
///     Sends a POST request to the token refresh endpoint with the device information.
///   </li>
///   <li>
///     Sets the token refresh date regardless of success or failure.
///   </li>
///   <li>
///     If the request is successful, processes the response and updates the session.
///   </li>
///   <li>
///     Logs the success and updates user audit information.
///   </li>
///   <li>
///     Restarts necessary timers and managers.
///   </li>
///   <li>
///     Sets the token refresh flag to false and calls the completion handler with <code>true</code>.
///   </li>
///   <li>
///     If the request fails, handles the error and calls the completion handler with <code>false</code>.
///   </li>
/// </ol>
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Ensure the internet connection is available before calling this method.
///   </li>
///   <li>
///     Only one refresh operation should be active at a time.
///   </li>
/// </ol>
/// \param completion A closure that takes a Boolean value indicating the success (<code>true</code>) or failure (<code>false</code>) of the token refresh operation.
///
- (void)refreshTokenWithCompletion:(void (^ _Nonnull)(BOOL))completion;
@end


/// <code>GTTollrunManager</code> manages the start and stop of toll runs within the system.
/// This singleton class provides functionality to initiate and conclude toll runs, including handling the necessary API calls, location services, and session management. It also manages notifications related to the success or failure of toll run operations.
SWIFT_CLASS("_TtC16GeoTollFramework16GTTollrunManager")
@interface GTTollrunManager : NSObject
/// Singleton instance of GTTollrunManager
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTTollrunManager * _Nonnull instance;)
+ (GTTollrunManager * _Nonnull)instance SWIFT_WARN_UNUSED_RESULT;
/// Starts the toll run process.
/// This method initiates the toll run process by checking session states, starting location services,
/// and calling the necessary APIs to start a toll run.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Handles both temp and actual toll run starts.
///   </li>
///   <li>
///     Ensures location services are started if required.
///   </li>
/// </ol>
- (void)start;
/// Stops the toll run process.
/// This method initiates the stopping of a toll run by sending the necessary API requests and performing clean-up tasks.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Handles both success and failure scenarios.
///   </li>
///   <li>
///     Sends notifications based on the stop status.
///   </li>
/// </ol>
- (void)stop;
/// Stops the actual toll run by sending a POST request to the server.
/// This method performs the necessary actions to stop a toll run, such as sending a POST request to the server
/// and handling the response.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Handles success and failure cases.
///   </li>
///   <li>
///     Sends notifications based on the server response.
///   </li>
/// </ol>
- (void)stopTollRun;
/// Stops the temporary toll run process.
/// This public method initiates the stopping of a temporary toll run by executing the necessary tasks.
- (void)stopTempTollrun;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeoTollFramework18GTUserAuditManager")
@interface GTUserAuditManager : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTUserAuditManager * _Nonnull sharedInstance;)
+ (GTUserAuditManager * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
- (void)validateAndStoreUserAuditWithEvent:(NSString * _Nonnull)event value:(NSString * _Nonnull)value value2:(NSString * _Nonnull)value2 tollrunID:(NSString * _Nonnull)tollrunID;
- (void)sendUserAuditDataWithCompletion:(void (^ _Nullable)(void))completion;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeoTollFramework9GTUtility")
@interface GTUtility : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) GTUtility * _Nonnull sharedInstance;)
+ (GTUtility * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)startFramework;
- (void)startTimer;
- (void)stopTimer;
/// This method starts the TrueTimeService, initializes various managers, and handles the toll run process for available vehicles.
/// The method performs the following steps:
/// <ol>
///   <li>
///     Starts the TrueTimeService.
///   </li>
///   <li>
///     Checks if eToll and non-BLE tolling are enabled.
///   </li>
///   <li>
///     If no toll run is currently active, it retrieves the list of available vehicles.
///   </li>
///   <li>
///     Finds the first available vehicle and starts a toll run if a valid vehicle ID is found.
///   </li>
///   <li>
///     Initializes other managers and sets SDK statuses.
///   </li>
/// </ol>
/// important:
///
/// This method ensures that the toll run is only started if eToll and non-BLE tolling are enabled, and if a valid available vehicle is found. It also initializes other managers and logs the start of the SDK.
- (void)checkEtollTollrun;
/// Converts a dictionary to a JSON-formatted string.
/// \param dictionary The dictionary to convert to JSON.
///
///
/// returns:
/// A JSON-formatted string representing the dictionary.
- (NSString * _Nonnull)jsonStringFromDictionaryWithDictionary:(NSDictionary * _Nonnull)dictionary SWIFT_WARN_UNUSED_RESULT;
/// Terminates the application under certain conditions after a delay.
/// This method asynchronously schedules termination of the application after 5 seconds if specific conditions are met:
/// <ul>
///   <li>
///     The application state in <code>GTGlobalStateLogging</code> is “slu”.
///   </li>
///   <li>
///     Remote User Control (RUC) is enabled.
///   </li>
///   <li>
///     Bluetooth permission is required according to <code>GTSession</code>.
///   </li>
/// </ul>
/// If all conditions are satisfied, it logs an audit event and terminates the application process.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     This method ensures controlled termination of the application based on critical conditions.
///   </li>
/// </ol>
- (void)terminate;
/// This method checks for changes in audio routes and triggers appropriate actions.
/// This method delegates the processing of new location updates to the <code>GTLocationManager</code>.
/// It is responsible for initiating actions based on changes in audio routes, such as starting or stopping toll runs.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     This method ensures that toll runs are synchronized with current audio route changes.
///   </li>
/// </ol>
- (void)checkStartOrStopTollRun;
/// Checks for available audio routes to manage the toll run state.
/// This method checks for available audio routes and handles the toll run state:
/// <ol>
///   <li>
///     If a vehicle is found and connected via Bluetooth, the toll run is started using the vehicle ID.
///   </li>
///   <li>
///     If no vehicle is found but the session has a valid vehicle ID, it starts the toll run.
///   </li>
/// </ol>
///
/// returns:
/// <code>true</code> if a toll run is started or if a matching vehicle is found and connected via Bluetooth; <code>false</code> otherwise.
- (BOOL)checkAndManageTollRun SWIFT_WARN_UNUSED_RESULT;
/// This method checks the current speed of the vehicle and stops the toll run if necessary.
/// The method retrieves the current speed from the provided <code>CLLocation</code> object and compares it with the minimum speed limit.
/// If the speed is greater than the minimum speed limit, it logs the event and prevents stopping the toll run.
/// Otherwise, it posts a notification indicating that the toll run will stop, records the vehicle speed audit, and stops the toll run.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     The method handles both starting and stopping the toll run based on the vehicle speed.
///   </li>
/// </ol>
/// \param location The <code>CLLocation</code> object containing the current location and speed information.
///
- (void)checkAndStopTollrun:(CLLocation * _Nonnull)location;
- (void)logCurrentAvailableAudioRoutes:(NSString * _Nonnull)recordingState;
/// This method checks if the authentication token has expired and performs a refresh if necessary.
/// The method determines the expiration status of the token. If the token is expired and no other refresh process is currently running, it initiates a refresh operation.
/// If a refresh is already in progress, it simply invokes the completion handler with <code>true</code>.
/// If the token is not expired, it directly invokes the completion handler with <code>true</code>.
/// important:
///
/// This method ensures that only one refresh process is active at a time. It uses a flag to indicate if a refresh API call is currently being made. If a refresh is already in progress, it avoids initiating another refresh request and simply completes the operation.
/// \param completion An optional closure that takes a Boolean value. It is called when the token check and refresh process is complete.
/// The Boolean value indicates whether the refresh was successful (<code>true</code>) or not (<code>false</code>). If the token is not expired, the closure is called with <code>true</code> immediately.
///
- (void)checkAndRefreshTokenWithCompletion:(void (^ _Nullable)(BOOL))completion;
/// This method checks if the authentication token has expired or is about to expire.
/// The method performs several checks to determine token expiration:
/// <ol>
///   <li>
///     It verifies if the app version has changed.
///   </li>
///   <li>
///     It retrieves the token and refresh token expiration times from local storage.
///   </li>
///   <li>
///     It calculates the age of the token in hours.
///   </li>
///   <li>
///     It assesses if any of the following conditions are met:
///   </li>
/// </ol>
/// <ul>
///   <li>
///     The token will expire in less than 3 hours.
///   </li>
///   <li>
///     The refresh token will expire in less than 24 hours.
///   </li>
///   <li>
///     The token age exceeds 24 hours.
///   </li>
///   <li>
///     The app version is higher than the previous version.
///   </li>
/// </ul>
/// If any of these conditions are true, it logs detailed information about the token’s status and returns <code>true</code>, indicating that the token is expired or requires refreshing. Otherwise, it returns <code>false</code>, indicating the token is still valid.
/// important:
///
/// The method logs information about the token’s expiration status and the age of the token. It also checks if the app version has changed, which could impact token validity.
///
/// returns:
/// A Boolean value indicating whether the token is expired (<code>true</code>) or not (<code>false</code>).
- (BOOL)checkRefreshTokenExpiration SWIFT_WARN_UNUSED_RESULT;
/// Logs an error from an API request and stores it as an audit event.
/// This method processes an <code>NSError</code> to extract its description and optionally retrieves additional response data if available.
/// It then logs the error details and stores the error information as a user audit event for further analysis.
/// important:
///
/// This method includes a print statement for debugging purposes and uses the <code>GTUserAuditManager</code> to record the error details in the audit log. The audit event is tagged with <code>AuditEventCode.API_ERROR</code> and includes the API URL and the error response.
/// \param error An <code>String</code> object representing the error encountered during an API request.
///
/// \param url A string representing the URL of the API request that failed.
///
- (void)storeErrorAsAuditWithError:(NSString * _Nonnull)error url:(NSString * _Nonnull)url;
/// Checks the accuracy of the given location and requests updates if necessary.
/// This method compares the horizontal accuracy of the given location with a minimum accuracy threshold.
/// If the accuracy is below the threshold, it logs a debug message and returns <code>true</code>.
/// If the accuracy is above the threshold, it requests location updates up to a maximum count, after which it resets the count and returns <code>false</code>.
/// \param location The <code>CLLocation</code> object representing the current location.
///
///
/// returns:
/// A Boolean value indicating whether the location accuracy is acceptable.
- (BOOL)checkLocationAccuracy:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
/// Prepares the device information for the token refresh request.
/// <h1>Discussion:</h1>
/// <ol>
///   <li>
///     Initializes an empty <code>NSMutableDictionary</code>.
///   </li>
///   <li>
///     Retrieves device information parameters using <code>helper</code>.
///   </li>
///   <li>
///     Returns the populated device information dictionary.
///   </li>
/// </ol>
///
/// returns:
/// A <code>NSMutableDictionary</code> containing device information.
- (NSMutableDictionary * _Nonnull)prepareDeviceInfo SWIFT_WARN_UNUSED_RESULT;
/// This method logs the user out of the application.
/// This method is responsible for notifying the application to redirect the user to the login screen. It posts a notification to trigger this action.
/// <h1>Discussion:</h1>
/// <ol>
///   <li>
///     Posts a notification named <code>redirectToLogin</code> to the default <code>NotificationCenter</code>.
///   </li>
///   <li>
///     This notification should be observed by the appropriate part of the application to handle the user redirection.
///   </li>
/// </ol>
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Ensure that there is an observer listening for the <code>redirectToLogin</code> notification to perform the actual redirection.
///   </li>
///   <li>
///     This method should be called when the user’s session is invalid or has expired.
///   </li>
/// </ol>
- (void)logUserOut;
/// Sends debug and audit logs, then terminates the application.
/// This method first fetches and sends debug logs using the <code>Helper</code> class.
/// It then sends user audit data through <code>GTUserAuditManager</code>.
/// After successfully sending the audit data, the application is terminated.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     The method handles both the debug logs and user audit data sequentially.
///   </li>
///   <li>
///     The application will terminate after the audit data is sent.
///   </li>
/// </ol>
/// <h1>Example</h1>
/// \code
/// sendDebugAndAuditLogs()
///
/// \endcode
- (void)sendDebugAndAuditLogs;
/// Resets the toll run ID to 0.
/// This method ensures that the toll run ID is reset before initiating a new toll run.
- (void)resetTollRunId;
@end

@class NSDate;
@class GTNotification;
@class AVAudioSessionPortDescription;

SWIFT_CLASS("_TtC16GeoTollFramework6Helper")
@interface Helper : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) Helper * _Nonnull sharedInstance;)
+ (Helper * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic) BOOL isTokenRefreshApiCallRunning;
@property (nonatomic) BOOL isStartTollRunApiCallRunning;
@property (nonatomic) BOOL isStopTollRunApiRunning;
@property (nonatomic) BOOL isRUCPayloadSending;
@property (nonatomic) BOOL iseTollPayloadSending;
@property (nonatomic) BOOL isSilentNotification;
@property (nonatomic) BOOL isUserAuditSending;
@property (nonatomic) BOOL shouldTerminate;
@property (nonatomic, readonly, copy) NSSet<AVAudioSessionPort> * _Nonnull builtInPortTypes;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)notificationUtilWithNotificationBody:(NSString * _Nonnull)body identifier:(NSString * _Nonnull)identifier logLevel:(uint32_t)logLevel checkSilent:(BOOL)checkSilent;
- (NSString * _Nonnull)convertToLocalWithTimeStamp:(NSString * _Nonnull)timeStamp SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)convertDateToStringWithTimeStamp:(NSDate * _Nonnull)timeStamp SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)convertToUTCWithDate:(NSDate * _Nonnull)date SWIFT_WARN_UNUSED_RESULT;
- (NSInteger)convertToMillisecondsWithDate:(NSString * _Nonnull)date SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)convertMillisecondsToDateWithMilliseconds:(int64_t)milliseconds SWIFT_WARN_UNUSED_RESULT;
- (void)printAuditLogWithEventSource:(NSString * _Nonnull)eventSource event:(NSString * _Nonnull)event message:(NSString * _Nonnull)message eventClass:(NSString * _Nonnull)eventClass eventMethod:(NSString * _Nonnull)eventMethod level:(NSString * _Nonnull)level;
- (void)printLogWithEventSource:(NSString * _Nonnull)eventSource event:(NSString * _Nonnull)event message:(NSString * _Nonnull)message eventClass:(NSString * _Nonnull)eventClass eventMethod:(NSString * _Nonnull)eventMethod level:(NSString * _Nonnull)level;
- (void)printLogWithEventSource:(NSString * _Nonnull)eventSource event:(NSString * _Nonnull)event message:(NSString * _Nonnull)message eventClass:(NSString * _Nonnull)eventClass eventMethod:(NSString * _Nonnull)eventMethod createdAt:(NSString * _Nonnull)createdAt sequence:(NSString * _Nonnull)sequence logStatus:(NSString * _Nonnull)logStatus level:(NSString * _Nonnull)level;
- (void)printLogWithEventSource:(NSString * _Nonnull)eventSource event:(NSString * _Nonnull)event message:(NSString * _Nonnull)message eventClass:(NSString * _Nonnull)eventClass eventMethod:(NSString * _Nonnull)eventMethod createdAt:(NSString * _Nonnull)createdAt sequence:(NSString * _Nonnull)sequence logStatus:(NSString * _Nonnull)logStatus serverAnkTime:(NSString * _Nonnull)serverAnkTime level:(NSString * _Nonnull)level;
- (void)storeLocationsWithEventSource:(NSString * _Nonnull)eventSource event:(NSString * _Nonnull)event message:(NSString * _Nonnull)message eventClass:(NSString * _Nonnull)eventClass eventMethod:(NSString * _Nonnull)eventMethod sequenceTime:(NSString * _Nonnull)sequenceTime sequence:(NSString * _Nonnull)sequence sequenceStatus:(NSString * _Nonnull)sequenceStatus sequenceAnkTime:(NSString * _Nonnull)sequenceAnkTime isLogForAudit:(BOOL)isLogForAudit level:(NSString * _Nonnull)level;
- (void)removeDataBase;
- (NSString * _Nonnull)getDocumentsDirectory SWIFT_WARN_UNUSED_RESULT;
- (void)shareLocationCSV;
- (void)fetchAndSendLogs;
- (void)sendUserAuditLogs;
- (NSMutableDictionary * _Nonnull)getDeviceInfoParametersWithRequestParam:(NSMutableDictionary * _Nonnull)requestParam SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getDeviceUUID SWIFT_WARN_UNUSED_RESULT;
/// This method creates JSON string.
/// Here is the discussion. This method creates JSOn string from dictionary and returns JSONString.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters can be <em>Any</em> type
///   </li>
/// </ol>
/// \param params Dictionary.
///
///
/// returns:
/// Json string as String.
- (NSString * _Nonnull)createJSONString:(id _Nonnull)params SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)jsonStringFromDictionary:(NSDictionary<NSString *, id> * _Nullable)dictionary SWIFT_WARN_UNUSED_RESULT;
- (NSMutableDictionary * _Nullable)convertJSONStringToDictionaryWithJsonString:(NSString * _Nonnull)jsonString SWIFT_WARN_UNUSED_RESULT;
- (void)appIsActive;
- (void)appEnteredBackground;
- (void)appWillTerminate;
- (void)launchedDueToSignificantLocation;
- (void)launchedWithOptions;
- (void)exitingOuterGeofence;
- (void)exitingPlazaGeofence;
- (void)exitingGantryGeofence;
- (void)enteringOuterGeofence;
- (void)enteringPlazaGeofence;
- (void)enteringGantryGeofence;
/// Set Battery Level
/// Here is the discussion. This methods sets phone battery level of current class.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters must be <em>Double</em> type
///   </li>
/// </ol>
/// \param level Battery level.
///
- (void)setBatteryLevel:(double)level;
/// This method sends notification.
/// Here is the discussion. This method send the notification.
/// <h1>Notes:</h1>
/// <ol>
///   <li>
///     Parameters must be <em>GTNotification</em> type
///   </li>
/// </ol>
/// \param notification Notification.
///
- (void)sendNotification:(GTNotification * _Nonnull)notification;
/// This method fetches user vehicles
/// Here is the discussion. This method fetches all the available user vehicles from backend..
- (void)fetchUserVehicleWithIsVehicle:(BOOL)isVehicle vehicleID:(NSInteger)vehicleID completion:(void (^ _Nonnull)(id _Nullable, NSString * _Nullable))completion;
- (void)recordVehicleSpeedAudit:(NSString * _Nonnull)speed :(BOOL)forceLog;
/// This method removes the type from uid.
/// Here is the discussion. This method removes the port type from uid of the audio route passed.
/// <h1>Notes:</h1>
/// \param uid Route’s uid.
///
/// \param must be <em>String</em> type
///
- (NSString * _Nonnull)removeType:(NSString * _Nonnull)uid SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getUIDFor:(AVAudioSessionPortDescription * _Nonnull)input SWIFT_WARN_UNUSED_RESULT;
- (void)logSDKStart;
@end


SWIFT_CLASS("_TtC16GeoTollFramework15TrueTimeService")
@interface TrueTimeService : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) TrueTimeService * _Nonnull shared;)
+ (TrueTimeService * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (void)start;
- (NSDate * _Nullable)getCurrentTime SWIFT_WARN_UNUSED_RESULT;
@end






@interface UserAudit (SWIFT_EXTENSION(GeoTollFramework))
@property (nonatomic, copy) NSString * _Nullable event;
@property (nonatomic, copy) NSString * _Nullable tollrunId;
@property (nonatomic, copy) NSString * _Nullable usertime;
@property (nonatomic, copy) NSString * _Nullable utcTime;
@property (nonatomic, copy) NSString * _Nullable val;
@property (nonatomic, copy) NSString * _Nullable val2;
@property (nonatomic, copy) NSString * _Nullable vehicleId;
@end

#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
